# Separate data into X and y
X <- model.matrix(~ ., data = data[, -ncol(data)])  # Design matrix (excluding the y column)
# If lambda0 is not provided, create a sequence
if (is.null(lambda0)) {
lambda0 <- seq(lambda1, length(X), length.out = 100)
}
# Fit the SSLASSO model
result <- SSLASSO(X = X, y = y, penalty = "adaptive", variance = "fixed",
lambda1 = lambda1, lambda0 = lambda0, theta = theta)
# Set plot margins (bottom, left, top, right)
par(mar = c(6, 6, 2, 2))
# Set the plot dimensions (width, height) in inches
par(pin = c(plot_width, plot_height))
# Create the plot of coefficients
plot(result)
# Extract selection indicators and determine which variables were ever selected
selected_variables <- result$select
ever_selected <- apply(selected_variables, 1, max)
# Return the results as a list
return(list(coefficients = result$beta, ever_selected = ever_selected, plot = result))
}
# Call the function with the Crimes data
ssl_crime <- fit_crime_sslasso(data = df, y = df$ViolentCrimesPerPop)
ssl_crime
# Call the function with the Crimes data
ssl_crime <- fit_crime_sslasso(data = df, y = df$ViolentCrimesPerPop)
ssl_crime
# The output contains coefficients, ever_selected, and plot
ssl_crime$coefficients
ssl_crime$ever_selected
1003+928
1003+928
data = df
seq(1, nrow(data)
seq(1, nrow(data)
seq(1, nrow(data)
seq(1, nrow(data),)
seq(1, nrow(data),)
data
# Separate data into X and y
X <- model.matrix(~ ., data = data[, -ncol(data)])  # Design matrix (excluding the y column)
X
View(X)
data[, -ncol(data)]
model.matrix(~ ., data = data[, -ncol(data)])
View(data)
summary(data)
X <- model.matrix(~ ., data = data[, -ncol(data)])
summary(X)
#### SOURCE DATA FRAMES AND VECTORS OF CRIME DATA ####
# Source the file that contains the crime data
source("data_crime_raw.R")
View(df)
check_data <- function(data) {
# Loop over columns
for (col in names(data)) {
# Check if the column is numeric
if (!is.numeric(data[[col]])) {
stop(paste("Column", col, "is not numeric."))
}
# Check for missing values
if (anyNA(data[[col]])) {
stop(paste("Column", col, "contains missing values."))
}
}
# If no problems found, print a success message
print("All columns are numeric and contain no missing values.")
}
check_data(df)
#     theta - Prior mixing proportion.
#     eps - Convergence criterion.
#     plot_width - Width of the plot in inches.
#     plot_height - Height of the plot in inches.
# OUTPUTS:
#     A list containing:
#         coefficients - The fitted matrix of coefficients.
#         ever_selected - A binary vector indicating which variables were
#                        ever selected along the regularization path.
#         plot - A plot of the coefficient paths for the fitted model.
fit_crime_sslasso <- function(data, y, lambda1 = 1, lambda0 = seq(1, nrow(data),),
theta = 0.5, eps = 0.001, plot_width = 6, plot_height = 4) {
# Input checks
# Check that 'data' is a data frame
if (!is.data.frame(data)) {
stop("'data' must be a data frame.")
}
# Check that 'lambda1' is a positive numeric value
if (!is.numeric(lambda1) || lambda1 <= 0) {
stop("'lambda1' must be a positive numeric value.")
}
# Check that 'lambda0' is a numeric sequence
if (!is.numeric(lambda0)) {
stop("'lambda0' must be a numeric sequence.")
}
# Check that 'theta' is a numeric value between 0 and 1
if (!is.numeric(theta) || theta < 0 || theta > 1) {
stop("'theta' must be a numeric value between 0 and 1.")
}
# Check that 'eps' is a small positive numeric value
if (!is.numeric(eps) || eps <= 0 || eps >= 1) {
stop("'eps' must be a small positive numeric value (0 < eps < 1).")
}
# Check that 'plot_width' is a positive numeric value
if (!is.numeric(plot_width) || plot_width <= 0) {
stop("'plot_width' must be a positive numeric value.")
}
# Check that 'plot_height' is a positive numeric value
if (!is.numeric(plot_height) || plot_height <= 0) {
stop("'plot_height' must be a positive numeric value.")
}
# Separate data into X and y
X <- model.matrix(~ ., data = data[, -ncol(data)])  # Design matrix (excluding the y column)
# If lambda0 is not provided, create a sequence
if (is.null(lambda0)) {
lambda0 <- seq(lambda1, length(X), length.out = 100)
}
# Fit the SSLASSO model
result <- SSLASSO(X = X, y = y, penalty = "adaptive", variance = "fixed",
lambda1 = lambda1, lambda0 = lambda0, theta = theta)
# Set plot margins (bottom, left, top, right)
par(mar = c(6, 6, 2, 2))
# Set the plot dimensions (width, height) in inches
par(pin = c(plot_width, plot_height))
# Create the plot of coefficients
plot(result)
# Extract selection indicators and determine which variables were ever selected
selected_variables <- result$select
ever_selected <- apply(selected_variables, 1, max)
# Return the results as a list
return(list(coefficients = result$beta, ever_selected = ever_selected, plot = result))
}
# Call the function with the Crimes data
ssl_crime <- fit_crime_sslasso(data = df, y = df$ViolentCrimesPerPop)
# Call the function with the Crimes data
ssl_crime <- fit_crime_sslasso(data = df, y = df$ViolentCrimesPerPop)
# The output contains coefficients, ever_selected, and plot
ssl_crime$coefficients
ssl_crime$ever_selected
View(df)
View(ssl_crime)
View(df)
# The output contains coefficients, ever_selected, and plot
ssl_crime$coefficients
ssl_crime$ever_selected
# The output contains coefficients, ever_selected, and plot
ssl_crime$coefficients
ssl_crime$ever_selected
data = df
# Separate data into X and y
X <- model.matrix(~ ., data = data[, -ncol(data)])  # Design matrix (excluding the y column)
View(X)
ssl_crime
# The output contains coefficients, ever_selected, and plot
ssl_crime$coefficients
ssl_crime$ever_selected
data = df
# Separate data into X and y
X <- model.matrix(~ ., data = data[, -ncol(data)])  # Design matrix (excluding the y column)
View(X)
#     method.tau - Method for handling tau (truncatedCauchy, halfCauchy, or fixed).
#     tau - The (estimated) value of tau in case "fixed" is selected for method.tau.
#     method.sigma - Method for handling sigma (Jeffreys or fixed).
#     burn - Number of burn-in MCMC samples.
#     nmc - Number of posterior draws to be saved.
#     thin - Thinning parameter of the chain.
#     alpha - Level for the credible intervals.
# OUTPUTS:
#     fit_horseshoe - The fitted horseshoe model.
#
fit_crime_horseshoe_model <- function(data, method.tau, tau, method.sigma, burn, nmc, thin, alpha) {
# Input checks
# Ensure data is a data.frame
if (!is.data.frame(data)) {
stop("Input data must be a data frame.")
}
# Ensure method.tau is one of the allowed values
if (!method.tau %in% c("truncatedCauchy", "halfCauchy", "fixed")) {
stop("method.tau must be one of 'truncatedCauchy', 'halfCauchy', or 'fixed'.")
}
# Ensure tau is a positive number if method.tau is "fixed"
if (method.tau == "fixed" && (!is.numeric(tau) || tau <= 0)) {
stop("tau must be a positive number when method.tau is 'fixed'.")
}
# Ensure method.sigma is one of the allowed values
if (!method.sigma %in% c("Jeffreys", "fixed")) {
stop("method.sigma must be one of 'Jeffreys' or 'fixed'.")
}
# Ensure burn, nmc, and thin are positive integers
if (!is.numeric(burn) || burn <= 0 || floor(burn) != burn ||
!is.numeric(nmc) || nmc <= 0 || floor(nmc) != nmc ||
!is.numeric(thin) || thin <= 0 || floor(thin) != thin) {
stop("burn, nmc, and thin must be positive integers.")
}
# Ensure alpha is a number between 0 and 1
if (!is.numeric(alpha) || alpha <= 0 || alpha >= 1) {
stop("alpha must be a number between 0 and 1.")
}
# Separate data into X and y
X <- model.matrix(~ ., data = data[, -ncol(data)])  # Design matrix (excluding the y column)
y <- data[[1]]              # Response vector (first column)
# Fit the horseshoe model using the horseshoe package
fit_horseshoe <- horseshoe::horseshoe(y = y, X = X,
method.tau = method.tau,
tau = tau,
method.sigma = method.sigma,
burn = burn,
nmc = nmc,
thin = thin,
alpha = alpha)
# Plot predicted values against the observed data
plot(y, X %*% fit_horseshoe$BetaHat, col = rep("blue", 20),
xlab = "Observed values", ylab = "Predicted values",
main = "Horseshoe Model: Predicted vs Observed Values")
# Print the posterior mean of tau
cat("Posterior mean of tau:", fit_horseshoe$TauHat, "\n")
# Load the Hmisc package for plotting credible intervals
library(Hmisc)
# Plot the credible intervals for coefficients
xYplot(Cbind(fit_horseshoe$BetaHat, fit_horseshoe$LeftCI, fit_horseshoe$RightCI) ~ 1:ncol(X),
type = c("p", "g", "g"), ylab = "Coefficients", xlab = "Variables",
main = "Credible Intervals for Coefficients")
# Return the fitted horseshoe model
return(fit_horseshoe)
}
# Run the functions an extract the results
# Truncated Cauchy prior
crime_horseshoe_t_model <- fit_crime_horseshoe_model(data = df,
method.tau = "truncatedCauchy",
tau = 1,
method.sigma = "Jeffreys",
burn = 1000,
nmc = 5000,
thin = 1,
alpha = 0.05)
#     method.tau - Method for handling tau (truncatedCauchy, halfCauchy, or fixed).
#     tau - The (estimated) value of tau in case "fixed" is selected for method.tau.
#     method.sigma - Method for handling sigma (Jeffreys or fixed).
#     burn - Number of burn-in MCMC samples.
#     nmc - Number of posterior draws to be saved.
#     thin - Thinning parameter of the chain.
#     alpha - Level for the credible intervals.
# OUTPUTS:
#     fit_horseshoe - The fitted horseshoe model.
#
fit_crime_horseshoe_model <- function(data, method.tau, tau, method.sigma, burn, nmc, thin, alpha) {
# Input checks
# Ensure data is a data.frame
if (!is.data.frame(data)) {
stop("Input data must be a data frame.")
}
# Ensure method.tau is one of the allowed values
if (!method.tau %in% c("truncatedCauchy", "halfCauchy", "fixed")) {
stop("method.tau must be one of 'truncatedCauchy', 'halfCauchy', or 'fixed'.")
}
# Ensure tau is a positive number if method.tau is "fixed"
if (method.tau == "fixed" && (!is.numeric(tau) || tau <= 0)) {
stop("tau must be a positive number when method.tau is 'fixed'.")
}
# Ensure method.sigma is one of the allowed values
if (!method.sigma %in% c("Jeffreys", "fixed")) {
stop("method.sigma must be one of 'Jeffreys' or 'fixed'.")
}
# Ensure burn, nmc, and thin are positive integers
if (!is.numeric(burn) || burn <= 0 || floor(burn) != burn ||
!is.numeric(nmc) || nmc <= 0 || floor(nmc) != nmc ||
!is.numeric(thin) || thin <= 0 || floor(thin) != thin) {
stop("burn, nmc, and thin must be positive integers.")
}
# Ensure alpha is a number between 0 and 1
if (!is.numeric(alpha) || alpha <= 0 || alpha >= 1) {
stop("alpha must be a number between 0 and 1.")
}
# Separate data into X and y
X <- model.matrix(~ ., data = data[, -ncol(data)])  # Design matrix (excluding the y column)
y <- data[[1]]              # Response vector (first column)
# Fit the horseshoe model using the horseshoe package
fit_horseshoe <- horseshoe::horseshoe(y = y, X = X,
method.tau = method.tau,
tau = tau,
method.sigma = method.sigma,
burn = burn,
nmc = nmc,
thin = thin,
alpha = alpha)
# Plot predicted values against the observed data
plot(y, X %*% fit_horseshoe$BetaHat, col = rep("blue", 20),
xlab = "Observed values", ylab = "Predicted values",
main = "Horseshoe Model: Predicted vs Observed Values")
# Print the posterior mean of tau
cat("Posterior mean of tau:", fit_horseshoe$TauHat, "\n")
# Load the Hmisc package for plotting credible intervals
library(Hmisc)
# Plot the credible intervals for coefficients
xYplot(Cbind(fit_horseshoe$BetaHat, fit_horseshoe$LeftCI, fit_horseshoe$RightCI) ~ 1:ncol(X),
type = c("p", "g", "g"), ylab = "Coefficients", xlab = "Variables",
main = "Credible Intervals for Coefficients")
# Return the fitted horseshoe model
return(fit_horseshoe)
}
# Run the functions an extract the results
# Truncated Cauchy prior
crime_horseshoe_t_model <- fit_crime_horseshoe_model(data = df,
method.tau = "truncatedCauchy",
tau = 1,
method.sigma = "Jeffreys",
burn = 1000,
nmc = 5000,
thin = 1,
alpha = 0.05)
data = df
method.tau = "truncatedCauchy"
tau = 1
method.sigma = "Jeffreys"
burn = 1000
nmc = 5000
thin = 1
alpha = 0.05
# Separate data into X and y
X <- model.matrix(~ ., data = data[, -ncol(data)])  # Design matrix (excluding the y column)
y <- data[[1]]              # Response vector (first column)
# Fit the horseshoe model using the horseshoe package
fit_horseshoe <- horseshoe::horseshoe(y = y, X = X,
method.tau = method.tau,
tau = tau,
method.sigma = method.sigma,
burn = burn,
nmc = nmc,
thin = thin,
alpha = alpha)
#     method.tau - Method for handling tau (truncatedCauchy, halfCauchy, or fixed).
#     tau - The (estimated) value of tau in case "fixed" is selected for method.tau.
#     method.sigma - Method for handling sigma (Jeffreys or fixed).
#     burn - Number of burn-in MCMC samples.
#     nmc - Number of posterior draws to be saved.
#     thin - Thinning parameter of the chain.
#     alpha - Level for the credible intervals.
# OUTPUTS:
#     fit_horseshoe - The fitted horseshoe model.
#
fit_crime_horseshoe_model <- function(data, method.tau, tau, method.sigma, burn, nmc, thin)#, alpha) {
#     method.tau - Method for handling tau (truncatedCauchy, halfCauchy, or fixed).
#     tau - The (estimated) value of tau in case "fixed" is selected for method.tau.
#     method.sigma - Method for handling sigma (Jeffreys or fixed).
#     burn - Number of burn-in MCMC samples.
#     nmc - Number of posterior draws to be saved.
#     thin - Thinning parameter of the chain.
#     alpha - Level for the credible intervals.
# OUTPUTS:
#     fit_horseshoe - The fitted horseshoe model.
#
fit_crime_horseshoe_model <- function(data, method.tau, tau, method.sigma, burn, nmc, thin) {#, alpha) {
#     method.tau - Method for handling tau (truncatedCauchy, halfCauchy, or fixed).
#     tau - The (estimated) value of tau in case "fixed" is selected for method.tau.
#     method.sigma - Method for handling sigma (Jeffreys or fixed).
#     burn - Number of burn-in MCMC samples.
#     nmc - Number of posterior draws to be saved.
#     thin - Thinning parameter of the chain.
#     alpha - Level for the credible intervals.
# OUTPUTS:
#     fit_horseshoe - The fitted horseshoe model.
#
fit_crime_horseshoe_model <- function(data, method.tau, tau, method.sigma, burn, nmc, thin) {#, alpha) {
fit_crime_horseshoe_model <- function(data, method.tau, tau, method.sigma, burn, nmc, thin) {#, alpha) {
# Input checks
# Ensure data is a data.frame
if (!is.data.frame(data)) {
stop("Input data must be a data frame.")
}
# Ensure method.tau is one of the allowed values
if (!method.tau %in% c("truncatedCauchy", "halfCauchy", "fixed")) {
stop("method.tau must be one of 'truncatedCauchy', 'halfCauchy', or 'fixed'.")
}
# Ensure tau is a positive number if method.tau is "fixed"
if (method.tau == "fixed" && (!is.numeric(tau) || tau <= 0)) {
stop("tau must be a positive number when method.tau is 'fixed'.")
}
# Ensure method.sigma is one of the allowed values
if (!method.sigma %in% c("Jeffreys", "fixed")) {
stop("method.sigma must be one of 'Jeffreys' or 'fixed'.")
}
# Ensure burn, nmc, and thin are positive integers
if (!is.numeric(burn) || burn <= 0 || floor(burn) != burn ||
!is.numeric(nmc) || nmc <= 0 || floor(nmc) != nmc ||
!is.numeric(thin) || thin <= 0 || floor(thin) != thin) {
stop("burn, nmc, and thin must be positive integers.")
}
# Ensure alpha is a number between 0 and 1
if (!is.numeric(alpha) || alpha <= 0 || alpha >= 1) {
stop("alpha must be a number between 0 and 1.")
}
# Separate data into X and y
X <- model.matrix(~ ., data = data[, -ncol(data)])  # Design matrix (excluding the y column)
y <- data[[1]]              # Response vector (first column)
# Fit the horseshoe model using the horseshoe package
fit_horseshoe <- horseshoe::horseshoe(y = y, X = X,
method.tau = method.tau,
tau = tau,
method.sigma = method.sigma,
burn = burn,
nmc = nmc,
thin = thin#,
# alpha = alpha)
# Plot predicted values against the observed data
plot(y, X %*% fit_horseshoe$BetaHat, col = rep("blue", 20),
#     method.tau - Method for handling tau (truncatedCauchy, halfCauchy, or fixed).
#     tau - The (estimated) value of tau in case "fixed" is selected for method.tau.
#     method.sigma - Method for handling sigma (Jeffreys or fixed).
#     burn - Number of burn-in MCMC samples.
#     nmc - Number of posterior draws to be saved.
#     thin - Thinning parameter of the chain.
#     alpha - Level for the credible intervals.
# OUTPUTS:
#     fit_horseshoe - The fitted horseshoe model.
#
fit_crime_horseshoe_model <- function(data, method.tau, tau, method.sigma, burn, nmc, thin, alpha) {
#     method.tau - Method for handling tau (truncatedCauchy, halfCauchy, or fixed).
#     tau - The (estimated) value of tau in case "fixed" is selected for method.tau.
#     method.sigma - Method for handling sigma (Jeffreys or fixed).
#     burn - Number of burn-in MCMC samples.
#     nmc - Number of posterior draws to be saved.
#     thin - Thinning parameter of the chain.
#     alpha - Level for the credible intervals.
# OUTPUTS:
#     fit_horseshoe - The fitted horseshoe model.
#
fit_crime_horseshoe_model <- function(data, method.tau, tau, method.sigma, burn, nmc, thin, alpha){
# Run the functions an extract the results
# Truncated Cauchy prior
crime_horseshoe_t_model <- fit_crime_horseshoe_model(data = df,
method.tau = "truncatedCauchy",
#tau = 1,
method.sigma = "Jeffreys",
burn = 1000,
nmc = 5000,
thin = 10)#,
?horseshoe
#     method.tau - Method for handling tau (truncatedCauchy, halfCauchy, or fixed).
#     tau - The (estimated) value of tau in case "fixed" is selected for method.tau.
#     method.sigma - Method for handling sigma (Jeffreys or fixed).
#     burn - Number of burn-in MCMC samples.
#     nmc - Number of posterior draws to be saved.
#     thin - Thinning parameter of the chain.
#     alpha - Level for the credible intervals.
# OUTPUTS:
#     fit_horseshoe - The fitted horseshoe model.
#
fit_crime_horseshoe_model <- function(data, method.tau, tau, method.sigma,
burn, nmc, thin, alpha) {
# Input checks
# Ensure data is a data.frame
if (!is.data.frame(data)) {
stop("Input data must be a data frame.")
}
# Ensure method.tau is one of the allowed values
if (!method.tau %in% c("truncatedCauchy", "halfCauchy", "fixed")) {
stop("method.tau must be one of 'truncatedCauchy', 'halfCauchy', or 'fixed'.")
}
# Ensure tau is a positive number if method.tau is "fixed"
if (method.tau == "fixed" && (!is.numeric(tau) || tau <= 0)) {
stop("tau must be a positive number when method.tau is 'fixed'.")
}
# Ensure method.sigma is one of the allowed values
if (!method.sigma %in% c("Jeffreys", "fixed")) {
stop("method.sigma must be one of 'Jeffreys' or 'fixed'.")
}
# Ensure burn, nmc, and thin are positive integers
if (!is.numeric(burn) || burn <= 0 || floor(burn) != burn ||
!is.numeric(nmc) || nmc <= 0 || floor(nmc) != nmc ||
!is.numeric(thin) || thin <= 0 || floor(thin) != thin) {
stop("burn, nmc, and thin must be positive integers.")
}
# Ensure alpha is a number between 0 and 1
if (!is.numeric(alpha) || alpha <= 0 || alpha >= 1) {
stop("alpha must be a number between 0 and 1.")
}
# Separate data into X and y
X <- model.matrix(~ ., data = data[, -ncol(data)])  # Design matrix (excluding the y column)
y <- data[[1]]              # Response vector (first column)
# Fit the horseshoe model using the horseshoe package
fit_horseshoe <- horseshoe::horseshoe(y = y, X = X,
method.tau = method.tau,
tau = tau,
method.sigma = method.sigma,
burn = burn,
nmc = nmc,
thin = thin)#,
# alpha = alpha)
# Plot predicted values against the observed data
plot(y, X %*% fit_horseshoe$BetaHat, col = rep("blue", 20),
xlab = "Observed values", ylab = "Predicted values",
main = "Horseshoe Model: Predicted vs Observed Values")
# Print the posterior mean of tau
#cat("Posterior mean of tau:", fit_horseshoe$TauHat, "\n")
# Load the Hmisc package for plotting credible intervals
#library(Hmisc)
# Plot the credible intervals for coefficients
xYplot(Cbind(fit_horseshoe$BetaHat, fit_horseshoe$LeftCI, fit_horseshoe$RightCI) ~ 1:ncol(X),
type = c("p", "g", "g"), ylab = "Coefficients", xlab = "Variables",
main = "Credible Intervals for Coefficients")
# Return the fitted horseshoe model
return(fit_horseshoe)
}
# Run the functions an extract the results
# Truncated Cauchy prior
crime_horseshoe_t_model <- fit_crime_horseshoe_model(data = df,
method.tau = "truncatedCauchy",
#tau = 1,
method.sigma = "Jeffreys",
burn = 1000,
nmc = 5000,
thin = 10)#,
crime_horseshoe_t_model
